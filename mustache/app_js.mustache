/* global $,window,document,hljs */
/* vim: set ft=javascript: */

// Objects

// ====================  Accordian

function Accordian(sel, delay) {
  this.delay = delay || 400;
  this.sel = sel || '.side-nav';
  this.sliderCon = 'dt + div';
  this.sliderHeader = 'dt';

  // Toggle TOC nav
  this.collapseAll(0);
  this.attach_click();

}

Accordian.prototype.attach_click = function() {
  var self = this;
  $(this.sel +' ' + this.sliderHeader).click(function(){
    self.collapseAll();
    $(this).next(this.sliderCon).stop().slideToggle(self.delay);
  });
};

Accordian.prototype.setTo = function (id){
  var $a = $(this.sel + ' dd a[href=' + id + ']');
  var $con = $a.parents('dt + div');

  this.collapseAll(undefined, $con);

  if ($con.css('display') === 'none' ) {
    $a.parents('dt + div').slideDown();
  } // else it is already down

};

Accordian.prototype.collapseAll = function(delay, ignore) {
  if (delay === undefined) { delay = this.delay; }

  if(ignore) {
    $(this.sel +' dt + div').not(ignore).slideUp(delay);
  } else {
    $(this.sel +' dt + div').slideUp(delay);
  }

};

// ====================  CodeSamples

function CodeSamples(settings) {

  // John Resig technique for new"-less" javascript
  if(!(this instanceof CodeSamples)) { return new CodeSamples(settings);}

  this.samples = {};
  this.langs = [];
  this.settings = {
    word_wrap: 10,
    indent: 4,
    min_chars: 10
  };

  this._settings(settings);
}

CodeSamples.prototype.add = function (samples_obj,lang) {
  $.extend(true,this.samples, samples_obj);
  if (lang) {this.langs.push(lang); }
};

CodeSamples.prototype.first_lang = function () {
  if(this.langs.length > 0) {
    return this.langs[0];
  }
  return '';
};

CodeSamples.prototype._inject = function (id,lang,sections) {
  var $container = $(id);
  var $lang_con = $('<div class="lang lang-'+lang+'"></div>');
  var self = this;

  // add each section
  // ...sections schema: [{header:"", syntax:"", content:""}]
  $.each(sections, function(i, sec){

    // Intelligently wrap the lines of code
    var wrapped = self._word_wrap_content(sec.content);

    // Build a template
    var template = '';
    template += '<section>';
    template += '<small>'+Date.now()+'</small>';
    template += '<h6 class="section-header"> '+ sec.header + '</h6>';
    template += '<pre><code class="'+sec.syntax+'">'+ wrapped + '</code></pre>';
    template += '</section>';

    $lang_con.append($(template));
  });

  // Remove old lang
  $container.find('.lang-'+lang).remove();

  $container.append($lang_con);
};

CodeSamples.prototype._each_section = function (fn) {
  var self = this;

  // Iterate over classname/operationId/languages/sections
  $.each(this.samples, function(classname,ops){
    $.each(ops, function(opid, langs){
      $.each(langs, function(lang, sections){
        var id = '#code-samples-'+classname+'-'+opid;
        fn.call(self,id,lang,sections);
      });
    });
  });
};

CodeSamples.prototype._word_wrap_content = function(content) {

  // normalize newlines, then tabs->spaces, then split
  var lines = content
              .replace(/(\r\n|\c\r|\r\c)/g, '\n')
              .replace(/\t/g, Array(this.settings.indent).join(' '))
              .split('\n');

  // Process indvidual lines
  var new_content = '';
  for (var i = lines.length - 1; i >= 0; i--) {
    new_content += this._word_wrap_line(lines[i]) + '\n';
  }

  return new_content;
};

// format each line, and if that line creates more lines, recursively format those.
// return a string of formatted lines
CodeSamples.prototype._word_wrap_line = function(line, appendage) {

  // Only work on lines larger than the word wrap
  if (line.length < this.settings.word_wrap) { return line;}

  appendage = appendage || ' \\';
  var wrap = this.settings.word_wrap - appendage.length;

  // var break_regex = /([, &?][^, &?]*)$/;
  var break_regex = /[\/? ,&.][^\/  ? ,&.]*$/;

  var break_point = line
  .slice(0,wrap) // only search visible text (with the assumed appendage)
  .replace(break_regex, '') // kill everything after the last match
  .length; // length == breakpoint

  // Don't wrap wrap if the resulting string will be less than minimum
  if (break_point < this.settings.min_chars) {
    break_point = wrap;
  }

  // Divide string based on break_point
  var str = line.slice(0, break_point );
  var remain = line.slice( break_point );

  // Process the remaining str, and include appendage to str if so
  if(remain.length > 0) {
    str += appendage;
   remain = Array(this.settings.indent).join(' ') + remain;
   str += '\n' ;
   str += this._word_wrap_line(remain,appendage);
  }

  return str;
};

CodeSamples.prototype.inject = function(settings) {
  var self = this;
  self._settings(settings);

  this._each_section(function(id,lang,sections){
    self._inject(id,lang,sections);
  });

};

CodeSamples.prototype._settings = function(obj) {
  $.extend(this.settings, obj);
  // Make sure we don't wrap with less than 8 chars
  this.settings.word_wrap = Math.max(this.settings.word_wrap, 8);
};

// ====================  ResizeChoker

function ResizeChoker(choke) {
  this.choke = choke || 300;
  this.listeners = [];
  this.counter = 0;
}

ResizeChoker.prototype.init = function() {
  var self = this;
  $(window).resize(function(){
    // Throttle, so that we only call 'resize' sparingly
    if (self.timeout) { clearTimeout(self.timeout); }
    self.timeout = setTimeout(function(){
      self.emit();
    },self.choke);
  });
};

ResizeChoker.prototype.emit = function() {
  this.counter++;
  for (var i = this.listeners.length - 1; i >= 0; i--) {
    this.listeners[i].call(this);
  }
};

ResizeChoker.prototype.add = function(fn) {
  this.listeners.push(fn);
};


// ====================  Integrated functions


function show_lang(lang) {
  // Show sections that are interested...
  $('#wrapper').attr('data-show-lang',lang);

  // Toggle active state on code-bar item
  $('#code-bar [data-lang]').removeClass('active');
  $('#code-bar [data-lang="'+lang+'"').addClass('active');
}

function init_code_bar(cs) {
  $('#code-bar dd a').click(function(e){
    e.preventDefault();

    var lang = $(this).parent().attr('data-lang');
    show_lang(lang);
  });

  show_lang(cs.first_lang());
}

function init_code_samples(cs) {
  if (!window.code) {
    console.log('we have no code samples... :(');
    return;
  }

  var _langs = [];
  for (var lang in window.code) {
    _langs.push(lang);
    cs.add(window.code[lang], lang);
  }

  console.log('found '+ _langs.length + ' langs: ' + _langs.join(','));
}

function attach_toc_listeners() {

  window.navAccordian = new Accordian('dl.side-nav');

  // Handle flyout TOC
  $('.mobile-only .menu-icon').click(function(){
    $('#wrapper').addClass('show-nav-section');
  });
  // NOTE: is this efficient, having a click event for escaping the fly-out toc?
  $('a.side-nav-item, #main-wrapper').click(function(){
    $('#wrapper').removeClass('show-nav-section');
  });
  $(document).keyup(function(e) {
    if (e.keyCode === 27) { // esc
      $('#wrapper').removeClass('show-nav-section');
    }
  });


  // Add highlight to nav items when we scroll into their domain
  add_scroll_highlighter();
}

function get_list_of_toc_hrefs () {

  // Get all the hrefs of the <a> tags, in the toc's side nav
  return $('.toc dd > a').map(function() {
    var href = $(this).attr('href');

    // Only return internal links
    if (href.indexOf('#') === 0) { return href; }

  }).get(); // #get -> convert to array from jQuery Obj
}


function add_scroll_highlighter() {


  var list_of_hrefs = get_list_of_toc_hrefs();

  $(window).scroll(function(){

    var $win = $(window);
    var winTop = $win.scrollTop();
    var topbarH = $('#top-bar').outerHeight(true);
    var top = winTop + topbarH;

    $.each(list_of_hrefs, function(i, href) {

      var $href = $(href);
      var hrefTop = $href.offset().top; // get the offset of the div from the top of page
      var hrefH= $href.parents('.api-section').outerHeight(true); // get the height of the div in question

      if (top >= hrefTop && top < (hrefTop + hrefH)) {
        window.navAccordian.setTo(href);
        $('a[href="' + href + '"]').addClass('nav-active');
      } else {
        $('a[href="' + href + '"]').removeClass('nav-active');
      }

    });
  });

}

function calc_word_wrap_length(el) {
  var $el = $(el).first();
  var width = $el.width();
  var px_per_char = calc_px_per_char($el);

  return Math.floor(width/px_per_char) - 1 ; // we reduce by one for margin of error
}

function calc_px_per_char(el) {

  var $el = $(el);
  var id = Date.now() + 'random';
  var str ='abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789' ;
  var $dummy = $('<span id="josh">\n'+str+'</span>');
  $dummy.css({
    'word_wrap': 'none'
  });
  $dummy.appendTo($el);
  var width = $dummy.width();
  $dummy.remove();

  var px_char  = width/str.length ;
  return px_char;
}

// on resize: set the standard for character length to break on
// on resize: copy code samples, then format/word-wrap
// on resize: re-inject active code samples
// on resize: apply syntax highlighting

// function attach_intelli_code_renderer() {

//   $('pre>code.bash:visible').each(function(i,block) {
//     intelli_render(block);
//   });

// }

// function calc_char_max_width(el) {
//   var $el = $(el);
//   $el.css('background-color', 'purple');
//   return 50;
// }

// function intelli_render(el, max_chars) {
//   var $el = $(el);
//   var $par = $el.parents('.api-section-right');
//   var scr_w = $el.prop('scrollWidth');
//   var par_w = $par.width();


//   if (scr_w > par_w) {
//     $el.css('background-color', 'red');

//     var lines = $el.html();
//     lines.replace(/[\r\n]/g, '\n');
//     lines = lines.split('\n');

//     var char_break, longest = 0;
//     for (var i = lines.length - 1; i >= 0; i--) {
//       longest = Math.max(longest, lines[i].length);
//     }

//     // A hackish way to get the average character width
//     var px_per_char = scr_w / longest;
//     var break_on_len = Math.floor(par_w / px_per_char);

//     // Break lines
//     for (var i = lines.length - 1; i >= 0; i--) {
//       longest = Math.max(longest, lines[i].length);
//     }

//     $el.append('\n' + Array(break_on_len).join('M'));

//   } else {
//     console.log('good: ' + par_w + '/' + scr_w);
//   }

// }


// ====================  Entry Point

function app_setup() {

  // Create a resize choker to ease resize events
  var resize = new ResizeChoker(300);
  resize.init();

  // TOC
  attach_toc_listeners();

  // Code Samples
  var cs = new CodeSamples();
  init_code_samples(cs);

  resize.add(function(){
    // make sure the element is visible, otherwise length will be 0
    word_wrap = calc_word_wrap_length('.api-section-right pre>code:visible');
    cs.inject({word_wrap: word_wrap});
  });

  init_code_bar(cs);

  // Highlight.js (code syntax highlighting)
  hljs.configure({
    classPrefix: ''
  });
  $('pre>code').each(function(i, block) {
    hljs.highlightBlock(block);
  });

  // Call the resize event to start things off
  resize.emit();
}
